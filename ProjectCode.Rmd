---
title: "Project"
author: "Katy Miles"
date: "`r Sys.Date()`"
output: html_document
---

```{Rcpp}
#include <RcppArmadillo.h>
// [[Rcpp::depends(RcppArmadillo)]]
using namespace Rcpp;
using namespace arma;

//[[Rcpp::export]]
List em_norm(NumericVector y, NumericVector p, NumericVector theta, 
             bool classes = false) {
  int n = y.size();
  NumericVector w1_tot(n);
  NumericVector w2_tot(n);
  double mu1 = theta[0];
  double mu2 = theta[1];
  double p1 = p[0];
  double p2 = p[1];
  for (int i = 0; i < 50; i++) {
      // E
      NumericVector w1 = p1 * dnorm(y, mu1);
      NumericVector w2 = p2 * dnorm(y, mu2);

      w1_tot = w1 / (w1 + w2);
      w2_tot = w2 / (w1 + w2);
      
      //M
      mu1 = sum(w1_tot * y) / sum(w1_tot);
      mu2 = sum(w2_tot * y) / sum(w2_tot);
      p1 = sum(w1_tot)/n;
      p2 = sum(w2_tot)/n;
  }
  NumericVector p_hat = {p1, p2};
  NumericVector theta_hat = {mu1, mu2};
  if (classes) {
      return List::create(p_hat, theta_hat, w1_tot, w2_tot);
  }
  return List::create(p_hat, theta_hat);
}

//[[Rcpp::export]]
List em_norm4(NumericVector y, NumericVector p, NumericVector theta, 
             bool classes = false) {
  int n = y.size();
  NumericVector w1_tot(n);
  NumericVector w2_tot(n);
  NumericVector w3_tot(n);
  NumericVector w4_tot(n);
  double mu1 = theta[0];
  double mu2 = theta[1];
  double mu3 = theta[2];
  double mu4 = theta[3];
  double p1 = p[0];
  double p2 = p[1];
  double p3 = p[2];
  double p4 = p[3];
  for (int i = 0; i < 100; i++) {
      // E
      NumericVector w1 = p1 * dnorm(y, mu1);
      NumericVector w2 = p2 * dnorm(y, mu2);
      NumericVector w3 = p3 * dnorm(y, mu3);
      NumericVector w4 = p4 * dnorm(y, mu4);

      w1_tot = w1 / (w1 + w2 + w3 + w4);
      w2_tot = w2 / (w1 + w2 + w3 + w4);
      w3_tot = w3 / (w1 + w2 + w3 + w4);
      w4_tot = w4 / (w1 + w2 + w3 + w4);
      
      //M
      mu1 = sum(w1_tot * y) / sum(w1_tot);
      mu2 = sum(w2_tot * y) / sum(w2_tot);
      mu3 = sum(w3_tot * y) / sum(w3_tot);
      mu4 = sum(w4_tot * y) / sum(w4_tot);
      p1 = sum(w1_tot)/n;
      p2 = sum(w2_tot)/n;
      p3 = sum(w3_tot)/n;
      p4 = sum(w4_tot)/n;
  }
  NumericVector p_hat = {p1, p2, p3, p4};
  NumericVector theta_hat = {mu1, mu2, mu3, mu4};
  if (classes) {
      return List::create(p_hat, theta_hat, w1_tot, w2_tot, w3_tot, w4_tot);
  }
  return List::create(p_hat, theta_hat);
}
```


```{r}
regularBoot = function(i, data, p, theta) {
  s = as.matrix(sample(data, length(data), replace = TRUE))
  if (length(p) > 2) {
    theta = unlist(em_norm4(s, p, theta))
  } else {
    theta = unlist(em_norm(s, p, theta))
  }
  return(theta)
}

strtBoot = function(data, classes, p, theta, iterations) {
  result = c()
  c = length(p)
  # Find the cluster proportions
  for (b in 1:iterations) {
    # Create bootstrap clusters
    fullSample = c()
    for (i in 1:c) {
      clusterSample = c()
      for (j in 1:length(classes)) {
        if (classes[j] == i) {
          clusterSample = append(clusterSample, data[j])
        }
      }
      if (length(clusterSample) > 0) {
        bootSample = sample(clusterSample, p[i]*length(data), TRUE)
        fullSample = append(fullSample, bootSample)
      }
    }
    
    # EM algorithm
    if (length(p) > 2) {
      result = rbind(result, unlist(em_norm4(fullSample, p, theta)))
    } else {
      result = rbind(result, unlist(em_norm(fullSample, p, theta)))
    }
  }
  return(result)
}
```


```{Rcpp}
#include <RcppArmadillo.h>
#include <bits/stdc++.h> 

// [[Rcpp::depends(RcppArmadillo)]]
using namespace Rcpp;
using namespace arma;
using namespace std;

namespace helper{ 
  NumericMatrix findPermutations(IntegerVector& c, int n) { 
    NumericVector perm(0);
    // Sort the given array 
    sort(c.begin(), c.end()); 
    // Find all possible permutations 
    do {
      for (int i = 0; i < n; i++) { 
        perm.push_back(c[i]); 
      } 
    } while (next_permutation(c.begin(), c.end()));
    NumericMatrix toReturn( c.size() , n , perm.begin() );
    return toReturn;
  }
  arma::vec perm_sort(arma::vec x, arma::vec y) {
      return x(arma::sort_index(y));
  }
}

//[[Rcpp::export]]
vec complh(int n, vec theta_hat, vec p_hat, NumericVector latent_labels) {
  // Generating sample
  int m = theta_hat.size();
  NumericVector x(n);
  NumericMatrix z(m, n);
  IntegerVector classes =  seq(1, m);
  for (int i = 0; i < n; i++) {
    if (latent_labels[i] == 1) {
      z(0,i) = 1;
    } else {
      z(0,i) = 0;
    }
    if (latent_labels[i] == 2) {
      z(1,i) = 1;
    } else {
      z(1,i) = 0;
    }
    if (m > 2) {
      if (latent_labels[i] == 3) {
        z(2,i) = 1;
      } else {
        z(2,i) = 0;
      }
      if (latent_labels[i] == 4) {
        z(3,i) = 1;
      } else {
        z(3,i) = 0;
      }
    }

    x[i] = R::rnorm(theta_hat[latent_labels[i] - 1], 1);
  }
  // Label Adjustment using complete log likelihood
  NumericMatrix perm = helper::findPermutations(classes, m);
  double ratio_sum = -10000000;
  NumericVector ratio(n);
  int max_perm = 0;
  for (int k = 0; k < perm.nrow(); k++) {
    NumericVector p = perm(k , _ );
    for (int i = 0; i < n; i++) {
      int num = 0;
      for (int j = 0; j < m; j++) {
        double mean = theta_hat[p[j] - 1];
        double like = R::dnorm(x[i], mean, 1, 0);
        double eval = z(j,i)*log(p_hat[p[j] - 1]*like);
        num = num + eval;
      }
      ratio[i] = num;
    }
    if (sum(ratio) > ratio_sum) {
      ratio_sum = sum(ratio);
      max_perm = k;
    }
  }
  vec y = perm(max_perm, _);
  vec sorted_p = helper::perm_sort(p_hat, y);
  vec sorted_theta = helper::perm_sort(theta_hat, y);
  return join_cols(sorted_p, sorted_theta);
}

//[[Rcpp::export]]
vec distlat(int n, vec theta_hat, vec p_hat, NumericVector latent_labels) {
  // Generating sample
  int m = theta_hat.size();
  NumericVector x(n);
  NumericMatrix z(m, n);
  IntegerVector classes =  seq(1, m);
  for (int i = 0; i < n; i++) {
    if (latent_labels[i] ==1) {
      z(0,i) = 1;
    } else {
      z(0,i) = 0;
    }
    if (latent_labels[i] == 2) {
      z(1,i) = 1;
    } else {
      z(1,i) = 0;
    }
    if (m > 2) {
      if (latent_labels[i] == 3) {
        z(2,i) = 1;
      } else {
        z(2,i) = 0;
      }
      if (latent_labels[i] == 4) {
        z(3,i) = 1;
      } else {
        z(3,i) = 0;
      }
    }
    x[i] = R::rnorm(theta_hat[latent_labels[i] - 1], 1);
  }
  // Label Adjustment using complete log likelihood
  NumericMatrix perm = helper::findPermutations(classes, m);

  double ratio_sum = -10000000;
  NumericVector ratio(n);
  int max_perm = 0;
  for (int k = 0; k < perm.nrow(); k++) {
    NumericVector p = perm(k , _ );
    for (int i = 0; i < n; i++) {
      int num = 0;
      for (int j = 0; j < m; j++) {
        double mean = theta_hat[p[j] - 1];
        double like = R::dnorm(x[i], mean, 1, 0);
        double eval = z(j,i)*p_hat[p[j] - 1]*like;
        num = num + eval;
      }
      ratio[i] = num;
    }
    if (sum(ratio) > ratio_sum) {
      ratio_sum = sum(ratio);
      max_perm = k;
    }
  }
  vec y = perm(max_perm, _);
  vec sorted_p = helper::perm_sort(p_hat, y);
  vec sorted_theta = helper::perm_sort(theta_hat, y);
  return join_cols(sorted_p, sorted_theta);
}
```


```{r}
library(tidyverse)
library(foreach)
library(doParallel)
library(rbenchmark)

simulations = function(true_p, true_theta, n) {
  regList = list()
  stratList = list()
  adjList = list()
  distList = list()
  for (j in 1:100) {
    # Simulate Data
    p_binom = rbinom(n, 1, true_p[1])
    data = (p_binom)*rnorm(n, true_theta[1]) + (1 - p_binom)*rnorm(n, true_theta[2])
    
    # Get initial values from kmeans
    initial_theta = sort(kmeans(data, 2)$centers[,1])
    initial_p = sort(kmeans(data, 2)$size / length(data))

    
    # Perform EM
    em_result = em_norm(data, initial_p, initial_theta, classes = TRUE)
    theta_hat = em_result[[2]]
    p_hat = em_result[[1]]
    
    # Set number of iterations
    iterations = 100
    
    # Perform Stratified Bootstrap
    w2_tot = em_result[[4]]
    w1_tot = em_result[[3]]
    
    df = data.frame(w1_tot, 
               w2_tot)
    df = df %>%
      rowwise() %>%
      mutate(Classification = ifelse(w1_tot == max(w1_tot, w2_tot), 1, 2))
    
    # Perform Non Parametric Bootstrap
    regBoot = t(matrix(unlist(mclapply(1:iterations, regularBoot, data = data, p = p_hat, theta = theta_hat)), nrow = 4))
    
    # Perform Parametric Bootstrap with Label Adjustment
    adjBoot = matrix(ncol = 4, nrow = iterations)
    for (i in 1:iterations) {
      # Take sample
      p_binom = rbinom(n, 1, p_hat[1])
      sample = (p_binom)*rnorm(n, theta_hat[1]) + (1 - p_binom)*rnorm(n,theta_hat[2])
      
      # Get estimates
      em = em_norm(sample, p_hat, theta_hat, classes = TRUE)
      
      w2_tot = em[[4]]
      w1_tot = em[[3]]
      
      df = data.frame(w1_tot, 
                 w2_tot)
      df = df %>%
        rowwise() %>%
        mutate(Classification = ifelse(w1_tot == max(w1_tot, w2_tot), 1, 2))
      
      # Label Adjustment
      adjBoot[i,] = complh(n, em[[2]], em[[1]], df$Classification)
    }
  
     # Perform Parametric Bootstrap with Label Adjustment DISTLAT
    distBoot = matrix(ncol = 4, nrow = iterations)
    for (i in 1:iterations) {
      # Take sample
      p_binom = rbinom(n, 1, p_hat[1])
      sample = (p_binom)*rnorm(n, theta_hat[1]) + (1 - p_binom)*rnorm(n,theta_hat[2])
      
      # Get estimates
      em = em_norm(sample, p_hat, theta_hat, classes = TRUE)
      
      w2_tot = em[[4]]
      w1_tot = em[[3]]
      
      df = data.frame(w1_tot, 
                 w2_tot)
      df = df %>%
        rowwise() %>%
        mutate(Classification = ifelse(w1_tot == max(w1_tot, w2_tot), 1, 2))
      
      # Label Adjustment
      distBoot[i,] = distlat(n, em[[2]], em[[1]], df$Classification)
    }
    
    sBoot = strtBoot(data, df$Classification, p_hat, theta_hat, iterations)
    regCI = c()
    adjCI = c()
    distCI = c()
    stratCI = c()
    # Get quantile CI
    for (i in 1:4) {
      regCI = rbind(regCI, quantile(regBoot[,i], c(.025,.975)))
      adjCI = rbind(adjCI, quantile(adjBoot[,i], c(.025, .975)))
      distCI = rbind(distCI, quantile(distBoot[,i], c(.025, .975)))
      stratCI = rbind(stratCI, quantile(sBoot[,i], c(.025,.975)))
    }
    regList = append(regList, list(regCI))
    adjList = append(adjList, list(adjCI))
    distList = append(distList, list(distCI))
    stratList = append(stratList, list(stratCI))
  }

    regCoverage = numeric(4)
    stratCoverage = numeric(4)
    adjCoverage = numeric(4)
    distCoverage = numeric(4)
    for (j in 1:4) {
      params = c(true_p, true_theta)
      coverage = numeric(iterations)
      for (i in 1:iterations) {
        CI = regList[[i]][j,]
        coverage[i] = ifelse(CI[1] < params[j] && CI[2] > params[j], 1, 0)
      }
      regCoverage[j] = sum(coverage)
      
      coverage = numeric(100)
      for (i in 1:100) {
        CI = adjList[[i]][j,]
        coverage[i] = ifelse(CI[1] < params[j] && CI[2] > params[j], 1, 0)
      }
      adjCoverage[j] = sum(coverage)
      
      coverage = numeric(100)
      for (i in 1:100) {
        CI = distList[[i]][j,]
        coverage[i] = ifelse(CI[1] < params[j] && CI[2] > params[j], 1, 0)
      }
      distCoverage[j] = sum(coverage)
      
      coverage = numeric(100)
      for (i in 1:100) {
        CI = stratList[[i]][j,]
        coverage[i] = ifelse(CI[1] < params[j] && CI[2] > params[j], 1, 0)
      }
      stratCoverage[j] = sum(coverage)
    }
    
    table = rbind(regCoverage, rbind(adjCoverage, rbind(distCoverage, stratCoverage)))
    return(table)
}

simulations4 = function(true_p, true_theta, n) {
  regList = list()
  stratList = list()
  adjList = list()
  distList = list()
  for (j in 1:100) {
    # Simulate Data
    p_multi = rmultinom(n, 1, true_p)
    dens = matrix(c(rnorm(n, true_theta[1]), rnorm(n, true_theta[2]), 
                    rnorm(n, true_theta[3]), rnorm(n, true_theta[4])), ncol = 4)
    
    data = p_multi[1,]*dens[1,] + p_multi[2,]*dens[2,] + 
      p_multi[3,]*dens[3,] + p_multi[4,]*dens[4,]
    
    # Get initial values from kmeans
    initial_theta = sort(kmeans(data, 4)$centers[,1])
    initial_p = sort(kmeans(data, 4)$size / length(data))
    
    # Perform EM
    em_result = em_norm4(data, initial_p, initial_theta, classes = TRUE)
    
    theta_hat = em_result[[2]]
    p_hat = em_result[[1]]
        
    # Set number of iterations
    iterations = 100
        
    # Perform Stratified Bootstrap
    w2_tot = em_result[[4]]
    w1_tot = em_result[[3]]
    w3_tot = em_result[[5]]
    w4_tot = em_result[[6]]
    
    df = data.frame(w1_tot, 
                   w2_tot, w3_tot, w4_tot)
    df = df %>%
          rowwise() %>%
          mutate(Classification = ifelse(w1_tot == max(w1_tot, w2_tot, w3_tot, w4_tot), 1, 
                                         ifelse(w2_tot == max(w1_tot, w2_tot, w3_tot, w4_tot), 2,
                                                ifelse(w3_tot == max(w1_tot, w2_tot, 
                                                                     w3_tot, w4_tot), 3, 4))))
        
    # Perform Non Parametric Bootstrap
    regBoot = t(matrix(unlist(mclapply(1:iterations, regularBoot, data = data, p = p_hat, theta = theta_hat)), nrow = 8))
    
    # Perform Parametric Bootstrap with Label Adjustment
    adjBoot = matrix(ncol = 8, nrow = iterations)
    for (i in 1:iterations) {
      # Simulate Data
      p_multi = rmultinom(n, 1, p_hat)
      dens = matrix(c(rnorm(n, theta_hat[1]), 
                        rnorm(n, theta_hat[2]),
                        rnorm(n, theta_hat[3]), 
                        rnorm(n, theta_hat[4])), ncol = 4)
      
      sample = p_multi[1,]*dens[1,] + p_multi[2,]*dens[2,] + 
      p_multi[3,]*dens[3,] + p_multi[4,]*dens[4,]
      
      # Get estimates
      em = em_norm4(sample, p_hat, theta_hat, classes = TRUE)
      
      w1_tot = em[[3]]
      w2_tot = em[[4]]
      w3_tot = em[[5]]
      w4_tot = em[[6]]
      
      df = data.frame(w1_tot, 
                 w2_tot, w3_tot, w4_tot)
      df = df %>%
            rowwise() %>%
            mutate(Classification = ifelse(w1_tot == max(w1_tot, w2_tot, w3_tot, w4_tot), 1, 
                                           ifelse(w2_tot == max(w1_tot, w2_tot, w3_tot, w4_tot), 2,
                                                  ifelse(w3_tot == max(w1_tot, w2_tot, 
                                                                       w3_tot, w4_tot), 3, 4))))
      
      # Label Adjustment
      adjBoot[i,] = complh(n, em[[2]], em[[1]], df$Classification)
    }
    
     # Perform Parametric Bootstrap with Label Adjustment DISTLAT
    distBoot = matrix(ncol = 8, nrow = iterations)
    for (i in 1:iterations) {
      # Simulate Data
      p_multi = rmultinom(n, 1, p_hat)
      dens = matrix(c(rnorm(n, theta_hat[1]), 
                        rnorm(n, theta_hat[2]),
                        rnorm(n, theta_hat[3]), 
                        rnorm(n, theta_hat[4])), ncol = 4)
      
      sample = p_multi[1,]*dens[1,] + p_multi[2,]*dens[2,] + 
      p_multi[3,]*dens[3,] + p_multi[4,]*dens[4,]
      
      # Get estimates
      em = em_norm4(sample, p_hat, theta_hat, classes = TRUE)
      
      w1_tot = em[[3]]
      w2_tot = em[[4]]
      w3_tot = em[[5]]
      w4_tot = em[[6]]
      
      df = data.frame(w1_tot, 
                 w2_tot, w3_tot, w4_tot)
      
      df = df %>%
          rowwise() %>%
          mutate(Classification = ifelse(w1_tot == max(w1_tot, w2_tot, w3_tot, w4_tot), 1, 
                                         ifelse(w2_tot == max(w1_tot, w2_tot, w3_tot, w4_tot), 2,
                                                ifelse(w3_tot == max(w1_tot, w2_tot, 
                                                                     w3_tot, w4_tot), 3, 4))))
      
      # Label Adjustment
      distBoot[i,] = distlat(n, em[[2]], em[[1]], df$Classification)
    }
  
      sBoot = strtBoot(data, df$Classification, p_hat, theta_hat, iterations)
  
      regCI = c()
      adjCI = c()
      distCI = c()
      stratCI = c()
      # Get quantile CI
      for (i in 1:8) {
        regCI = rbind(regCI, quantile(regBoot[,i], c(.025,.975)))
        adjCI = rbind(adjCI, quantile(adjBoot[,i], c(.025, .975)))
        distCI = rbind(distCI, quantile(distBoot[,i], c(.025, .975)))
        stratCI = rbind(stratCI, quantile(sBoot[,i], c(.025,.975)))
      }
      regList = append(regList, list(regCI))
      adjList = append(adjList, list(adjCI))
      distList = append(distList, list(distCI))
      stratList = append(stratList, list(stratCI))
    }

    
    regCoverage = numeric(8)
    stratCoverage = numeric(8)
    adjCoverage = numeric(8)
    distCoverage = numeric(8)
    for (j in 1:8) {
      params = c(true_p, true_theta)
      coverage = numeric(iterations)
      for (i in 1:iterations) {
        CI = regList[[i]][j,]
        coverage[i] = ifelse(CI[1] < params[j] && CI[2] > params[j], 1, 0)
      }
      regCoverage[j] = sum(coverage)
      
      coverage = numeric(100)
      for (i in 1:100) {
        CI = adjList[[i]][j,]
        coverage[i] = ifelse(CI[1] < params[j] && CI[2] > params[j], 1, 0)
      }
      adjCoverage[j] = sum(coverage)
      
      coverage = numeric(100)
      for (i in 1:100) {
        CI = distList[[i]][j,]
        coverage[i] = ifelse(CI[1] < params[j] && CI[2] > params[j], 1, 0)
      }
      distCoverage[j] = sum(coverage)
      
      coverage = numeric(100)
      for (i in 1:100) {
        CI = stratList[[i]][j,]
        coverage[i] = ifelse(CI[1] < params[j] && CI[2] > params[j], 1, 0)
      }
      stratCoverage[j] = sum(coverage)
    }
    
    table = rbind(regCoverage, rbind(adjCoverage, rbind(distCoverage, stratCoverage)))
    return(table)
}



```

100 Bootstrap runs, n = 100

Scenario 1: $$p_1 = 0.5, p_2 = 0.5, \mu_1 = 0, mu_2 = 0.5$$

```{r}
table1 = simulations(c(.5,.5), c(0, .5), 100)
colnames(table1) = c("P1", "P2", "Theta1", "Theta2")
knitr::kable(table1)
table1 = cbind(table1, Diff = .5)
```

Scenario 2: $$p_1 = 0.5, p_2 = 0.5, \mu_1 = 0, mu_2 = 1$$

```{r}
table2 = simulations(c(.5,.5), c(0, 1), 100)
colnames(table2) = c("P1", "P2", "Theta1", "Theta2")
knitr::kable(table2)
table2 = cbind(table2, Diff = rep(1, 4))
```

Scenario 3: $$p_1 = 0.5, p_2 = 0.5, \mu_1 = 0, \mu_2 = 1.5$$

```{r}
table3 = simulations(c(.5,.5), c(0, 1.5), 100)
colnames(table3) = c("P1", "P2", "Theta1", "Theta2")
knitr::kable(table3)
table3 = cbind(table3, Diff = rep(1.5, 4))
```

Scenario 4: $$p_1 = 0.5, p_2 = 0.5, \mu_1 = 0, \mu_2 = 2$$

```{r}
table4 = simulations(c(.5,.5), c(0, 2), 100)
colnames(table4) = c("P1", "P2", "Lambda 1", "Lambda 2")
knitr::kable(table4)
table4 = cbind(table4, Diff = rep(2, 4))
```

```{r}
plot_df = as.data.frame(rbind(table1, rbind(table2, rbind(table3, table4))))
plot_df = cbind(Method = rep(c("Non-Parametric", "COMPLH", "DISTLAT", "Strat"), 4), plot_df)
write.csv(plot_df, "first_table.csv", row.names = FALSE)
plot_simulations = function(param, options, plot_df, title, xlab, ylab) {
  yvar = sym(options[param])
  print(yvar)
  ggplot() + 
    geom_point(aes(Diff, !!yvar, color = Method), plot_df) + 
    geom_line(aes(Diff, !!yvar, color = Method), plot_df) + 
    theme_minimal() + 
    ggtitle(title) + 
    ylab(ylab) + 
    xlab(xlab) + 
    geom_hline(yintercept = 95, color = "black") + 
    theme(plot.title = element_text(hjust = 0.5))
}

p1 = plot_simulations(1, c("P1", "P2", "Theta1", "Theta2"), plot_df, "P", "", 
                      "Coverage Probability")
p2 = plot_simulations(3, c("P1", "P2", "Theta1", "Theta2"), plot_df, "Lambda 1", "Difference in Lambdas", "")
p3 = plot_simulations(4, c("P1", "P2", "Theta1", "Theta2"), plot_df, "Lambda 2", "", "")
ggsave("first_grid.jpeg",ggpubr::ggarrange(p1, p2, p3, common.legend = TRUE, nrow = 1),
       width = 10, height =7)
```

100 Bootstrap runs, n = 100

Scenario 1: $$p_1 = 0.2, p_2 = 0.8, \mu_1 = 0, \mu_2 = 0.5$$

```{r}
table1_2 = simulations(c(.2,.8), c(0, .5), 100)
colnames(table1_2) = c("P1", "P2", "Theta1", "Theta2")
knitr::kable(table1_2)
table1_2 = cbind(table1_2, Diff = rep(.5, 4))
```

Scenario 2: $$p_1 = 0.2, p_2 = 0.8, \mu_1 = 0, \mu_2 = 1$$

```{r}
table2_2 = simulations(c(.2,.8), c(0, 1), 100)
colnames(table2_2) = c("P1", "P2", "Theta1", "Theta2")
knitr::kable(table2_2)
table2_2 = cbind(table2_2, Diff = rep(1, 4))
```

Scenario 4: $$p_1 = 0.2, p_2 = 0.8, \mu_1 = 0, \mu_2 = 2$$

```{r}
table3_2 = simulations(c(.2,.8), c(0, 1.5), 100)
colnames(table3_2) = c("P1", "P2", "Theta1", "Theta2")
knitr::kable(table3_2)
table3_2 = cbind(table3_2, Diff = rep(1.5, 4))
```

Scenario 4: $$p_1 = 0.2, p_2 = 0.8, \mu_1 = 0, \mu_2 = 2$$

```{r}
table4_2 = simulations(c(.2,.8), c(0, 2), 100)
colnames(table4_2) = c("P1", "P2", "Theta1", "Theta2")
knitr::kable(table4_2)
table4_2 = cbind(table4_2, Diff = rep(2, 4))
```

```{r}
plot_df2 = as.data.frame(rbind(table1_2, rbind(table2_2, rbind(table3_2, table4_2))))
plot_df2 = cbind(Method = rep(c("Non-Parametric", "COMPLH", "DISTLAT", "Strat"), 4),plot_df2)
write.csv(plot_df2, "second_table.csv", row.names = FALSE)
p1 = plot_simulations(1, c("P1", "P2", "Theta1", "Theta2"), plot_df2, "P", "", 
                      "Coverage Probability")
p2 = plot_simulations(3, c("P1", "P2", "Theta1", "Theta2"), plot_df2, "Lambda 1", "Difference in Lambdas", "")
p3 = plot_simulations(4, c("P1", "P2", "Theta1", "Theta2"), plot_df2, "Lambda 2", "", "")
ggsave("second_grid.jpeg",ggpubr::ggarrange(p1, p2, p3, common.legend = TRUE, nrow = 1),
       width = 10, height =7)
```

100 Bootstrap runs, n = 100

Scenario 1: $$\pi_1 = \pi_2 = \pi_3 = \pi_4 = 0.25, \mu_1 = 0, \mu_2 = 1, \mu_3 = 2, \mu_4 = 3$$
```{r}
table1_3 = simulations4(rep(1/4,4), seq(0, 3, 1), 100)
colnames(table1_3) = c("P1", "P2", "P3", "P4", 
                     "Theta1", "Theta2", "Theta3", "Theta4")
knitr::kable(table1_3)
table1_3 = cbind(table1_3, Diff = rep(sqrt(sum(seq(0, 3, 1)^2)), 8))
```
Scenario 2:
```{r}
table2_3 = simulations4(rep(1/4,4), seq(0, 6, 2), 100)
colnames(table2_3) = c("P1", "P2", "P3", "P4", 
                     "Theta1", "Theta2", "Theta3", "Theta4")
knitr::kable(table2_3)
table2_3 = cbind(table2_3, Diff = rep(sqrt(sum(seq(0, 6, 2)^2)), 4))
```

Scenario 3:
```{r}
table3_3 = simulations4(rep(1/4,4), seq(0, 9, 3), 100)
colnames(table3_3) = c("P1", "P2", "P3", "P4", 
                     "Theta1", "Theta2", "Theta3", "Theta4")
knitr::kable(table3_3)
table3_3 = cbind(table3_3, Diff = rep(sqrt(sum(seq(0, 9, 3)^2)), 4))
```

Scenario 4:
```{r}
table4_3 = simulations4(rep(1/4,4), seq(0, 12, 4), 100)
colnames(table4_3) = c("P1", "P2", "P3", "P4", 
                     "Theta1", "Theta2", "Theta3", "Theta4")
knitr::kable(table4_3)
table4_3 = cbind(table4_3, Diff = rep(sqrt(sum(seq(0, 12, 4)^2)), 4))
```

```{r}
plot_df3 = as.data.frame(rbind(table1_3, rbind(table2_3, rbind(table3_3, table4_3))))
plot_df3 = cbind(Method = rep(c("Non-Parametric", "COMPLH", "DISTLAT", "Strat"), 4), plot_df3)
write.csv(plot_df3, "third_table.csv", row.names = FALSE)
p1 = plot_simulations(5, c("P1", "P2", "P3", "P4", "Theta1", "Theta2", "Theta3", "Theta4"), plot_df3, "Lambda 1", "", 
                      "Coverage Probability")
p2 = plot_simulations(6,c("P1", "P2", "P3", "P4", "Theta1", "Theta2", "Theta3", "Theta4"), 
                      plot_df3, "Lambda 2", "Difference in Lambdas", "")
p3 = plot_simulations(7, c("P1", "P2", "P3", "P4", "Theta1", "Theta2", "Theta3", "Theta4"), 
                      plot_df3, "Lambda 3", "", "")
p4 = plot_simulations(8, c("P1", "P2", "P3", "P4", "Theta1", "Theta2", "Theta3", "Theta4"),
                      plot_df3, "Lambda 4", "", "")
ggsave("third_grid.jpeg",ggpubr::ggarrange(p1, p2, p3,p4, common.legend = TRUE, nrow = 1),
       width = 10, height =7)
```

```{r}
plot_clusters = function(true_p, true_theta, n) {
  # Simulate Data
  p_multi = rmultinom(n, 1, true_p)
  dens = matrix(c(rnorm(n, true_theta[1]), rnorm(n, true_theta[2]), 
                  rnorm(n, true_theta[3]), rnorm(n, true_theta[4])), ncol = 4)
  
  data = p_multi[1,]*dens[1,] + p_multi[2,]*dens[2,] + 
    p_multi[3,]*dens[3,] + p_multi[4,]*dens[4,]
  
  # Get initial values from kmeans
  initial_theta = sort(kmeans(data, 4)$centers[,1])
  initial_p = sort(kmeans(data, 4)$size / length(data))
  
  # Perform EM
  em_result = em_norm4(data, initial_p, initial_theta, classes = TRUE)
  
  theta_hat = em_result[[2]]
  p_hat = em_result[[1]]
      
  # Set number of iterations
  iterations = 1000
      
  # Perform Stratified Bootstrap
  w2_tot = em_result[[4]]
  w1_tot = em_result[[3]]
  w3_tot = em_result[[5]]
  w4_tot = em_result[[6]]
  
  df = data.frame(w1_tot, 
                 w2_tot, w3_tot, w4_tot)
  df = df %>%
        rowwise() %>%
        mutate(Classification = ifelse(w1_tot == max(w1_tot, w2_tot, w3_tot, w4_tot), 1, 
                                       ifelse(w2_tot == max(w1_tot, w2_tot, w3_tot, w4_tot), 2,
                                              ifelse(w3_tot == max(w1_tot, w2_tot, 
                                                                   w3_tot, w4_tot), 3, 4))))
      
  # Perform Non Parametric Bootstrap
  theta = matrix(nrow = 0, ncol = 8)
  for (i in 1:1000) {
    s = as.matrix(sample(data, length(data), replace = TRUE))
    reg_list = em_norm4(s, p_hat, theta_hat, classes = TRUE)
    w1_tot = reg_list[[3]]
    w2_tot = reg_list[[4]]
    w3_tot = reg_list[[5]]
    w4_tot = reg_list[[6]]
    
    df_reg = data.frame(w1_tot, 
                 w2_tot, w3_tot, w4_tot)
    df_reg = df %>%
        rowwise() %>%
        mutate(Classification = ifelse(w1_tot == max(w1_tot, w2_tot, w3_tot, w4_tot), 1, 
                                       ifelse(w2_tot == max(w1_tot, w2_tot, w3_tot, w4_tot), 2,
                                              ifelse(w3_tot == max(w1_tot, w2_tot, 
                                                                   w3_tot, w4_tot), 3, 4))))
  }

t = em_norm4(s, p_hat, theta_hat, classes = TRUE)
  
  
  return(table)
}
```